<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Image Upload Fragment</title>
</head>
<body>

<!-- Image upload fragment -->
<div th:fragment="image-upload">
    <!-- 사진 업로드 -->
    <div class="mb-3">
        <h6 class="mb-2">
            <i class="bi bi-image text-success me-2"></i>사진 추가
        </h6>

        <!-- 이미지 업로드 컨테이너 -->
        <div class="mb-2" id="modal-image-upload-container">
            <!-- 업로드된 이미지 미리보기 및 URL 저장 영역 -->
        </div>

        <!-- 파일 선택 버튼 -->
        <div class="d-flex gap-2 align-items-center">
            <label class="btn btn-sm btn-outline-primary mb-0" for="modal-image-file-input">
                <i class="bi bi-upload me-1"></i> 사진 선택
            </label>
            <input accept="image/jpeg,image/png,image/gif,image/webp"
                   class="d-none"
                   id="modal-image-file-input"
                   multiple
                   type="file">
            <small class="text-muted" id="modal-upload-count">0/5</small>
        </div>
        <div class="form-text">JPG, PNG, GIF, WebP 형식 지원 (최대 5MB, 5장)</div>

        <!-- 업로드 진행 상태 표시 -->
        <div class="mt-2" id="modal-upload-progress" style="display: none;">
            <div class="progress" style="height: 20px;">
                <progress class="progress-bar progress-bar-striped progress-bar-animated"
                          id="modal-upload-progress-bar" max="100"
                          value="0">
                    <span id="modal-upload-progress-text">0%</span>
                </progress>
            </div>
        </div>
    </div>

    <!-- Image upload JavaScript -->
    <script th:inline="javascript">
        /**
         * 게시글 이미지 업로드 관리
         * S3 Presigned POST를 사용한 직접 업로드 방식 with CSRF 지원
         */

        class PostImageUploader {
            constructor() {
                this.maxImages = 5;
                this.maxFileSize = 5 * 1024 * 1024; // 5MB
                this.uploadedImages = [];
                this.uploadQueue = [];
                this.isUploading = false;
                this.csrfToken = null;
                this.csrfHeader = null;

                this.init();
            }

            init() {
                // CSRF 토큰 초기화
                this.initCsrfToken();

                const fileInput = document.getElementById('modal-image-file-input');
                if (!fileInput) return;

                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));

                // 모달이 닫힐 때 업로드된 이미지 초기화
                const modal = document.getElementById('modalCreateFeed');
                if (modal) {
                    modal.addEventListener('hidden.bs.modal', () => this.resetUploader());
                }
            }

            /**
             * Spring Security CSRF 토큰 초기화
             * meta 태그에서 토큰을 읽어옴
             */
            initCsrfToken() {
                const tokenMeta = document.querySelector('meta[name="_csrf"]');
                const headerMeta = document.querySelector('meta[name="_csrf_header"]');

                if (tokenMeta && headerMeta) {
                    this.csrfToken = tokenMeta.getAttribute('content');
                    this.csrfHeader = headerMeta.getAttribute('content');
                    console.log('CSRF 토큰 초기화 완료');
                } else {
                    console.warn('CSRF meta 태그를 찾을 수 없습니다. HTML head에 추가하세요.');
                }
            }

            /**
             * CSRF 토큰을 포함한 헤더 반환
             */
            getCsrfHeaders() {
                const headers = {
                    'Content-Type': 'application/json',
                };

                if (this.csrfToken && this.csrfHeader) {
                    headers[this.csrfHeader] = this.csrfToken;
                }

                return headers;
            }

            handleFileSelect(event) {
                const files = Array.from(event.target.files);

                if (this.uploadedImages.length + files.length > this.maxImages) {
                    this.showError(`최대 ${this.maxImages}장까지만 업로드할 수 있습니다.`);
                    event.target.value = '';
                    return;
                }

                // 파일 검증
                const validFiles = files.filter(file => this.validateFile(file));

                if (validFiles.length > 0) {
                    this.uploadQueue.push(...validFiles);
                    this.processUploadQueue();
                }

                // input 초기화 (같은 파일 재선택 가능하도록)
                event.target.value = '';
            }

            validateFile(file) {
                // 파일 타입 검증
                const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
                if (!allowedTypes.includes(file.type)) {
                    this.showError(`${file.name}: 지원하지 않는 파일 형식입니다.`);
                    return false;
                }

                // 파일 크기 검증
                if (file.size > this.maxFileSize) {
                    this.showError(`${file.name}: 파일 크기는 5MB를 초과할 수 없습니다.`);
                    return false;
                }

                return true;
            }

            /**
             * 이미지 파일에서 width와 height 추출
             * @param {File} file - 이미지 파일
             * @returns {Promise<{width: number, height: number}>}
             */
            async getImageDimensions(file) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const url = URL.createObjectURL(file);

                    img.onload = () => {
                        URL.revokeObjectURL(url); // 메모리 해제
                        resolve({
                            width: img.naturalWidth,
                            height: img.naturalHeight
                        });
                    };

                    img.onerror = () => {
                        URL.revokeObjectURL(url);
                        reject(new Error('이미지를 로드할 수 없습니다.'));
                    };

                    img.src = url;
                });
            }

            async processUploadQueue() {
                if (this.isUploading || this.uploadQueue.length === 0) return;

                this.isUploading = true;
                this.showProgress();

                while (this.uploadQueue.length > 0) {
                    const file = this.uploadQueue.shift();
                    try {
                        await this.uploadFile(file);
                    } catch (error) {
                        console.error('Upload failed:', error);
                        this.showError(`${file.name} 업로드 실패: ${error.message}`);
                    }
                }

                this.hideProgress();
                this.isUploading = false;
            }

            async uploadFile(file) {
                try {
                    // 0단계: 이미지 크기 추출
                    const dimensions = await this.getImageDimensions(file);

                    // 1단계: Presigned POST URL 요청 (CSRF 토큰 포함)
                    const uploadRequest = await this.requestPresignedPost(file, dimensions);

                    // 2단계: S3에 직접 업로드
                    await this.uploadToS3(file, uploadRequest);

                    // 3단계: 업로드 확인 (CSRF 토큰 포함)
                    const result = await this.confirmUpload(uploadRequest.key);

                    // 4단계: UI 업데이트
                    this.addImagePreview(file, result);
                    this.updateUploadCount();

                } catch (error) {
                    console.error('Upload error:', error);
                    throw error;
                }
            }

            async requestPresignedPost(file, dimensions) {
                const response = await fetch('/api/images/upload-request', {
                    method: 'POST',
                    headers: this.getCsrfHeaders(),
                    body: JSON.stringify({
                        fileName: file.name,
                        fileSize: file.size,
                        contentType: file.type,
                        width: dimensions.width,
                        height: dimensions.height,
                        imageType: "POST_IMAGE"
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Presigned URL 요청 실패');
                }

                return await response.json();
            }

            async uploadToS3(file, uploadRequest) {
                // Presigned PUT URL 방식 사용
                console.log(uploadRequest)
                console.log(uploadRequest.uploadUrl)
                let metadata = uploadRequest.metadata
                const response = await fetch(uploadRequest.uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': metadata['content-type'],
                        'x-amz-meta-content-type': metadata['content-type'],
                        'x-amz-meta-file-size': metadata['file-size'],
                        'x-amz-meta-height': metadata['height'],
                        'x-amz-meta-original-name': metadata['original-name'],
                        'x-amz-meta-width': metadata['width']
                    },
                    body: file
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('S3 업로드 실패:', response.status, errorText);
                    throw new Error(`S3 업로드 실패: ${response.body}`);
                }
            }

            async confirmUpload(key) {
                const response = await fetch(`/api/images/upload-confirm?key=${encodeURIComponent(key)}`, {
                    method: 'POST',
                    headers: this.getCsrfHeaders()
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || '업로드 확인 실패');
                }

                return await response.json();
            }

            addImagePreview(file, uploadResult) {
                const container = document.getElementById('modal-image-upload-container');
                const index = this.uploadedImages.length;

                // 미리보기 이미지 생성
                const reader = new FileReader();
                reader.onload = (e) => {
                    const previewHtml = `
                    <div class="image-preview-item position-relative d-inline-block me-2 mb-2" data-index="${index}">
                        <img src="${e.target.result}"
                             alt="Preview ${index + 1}"
                             class="rounded border"
                             style="width: 100px; height: 100px; object-fit: cover;">
                        <button type="button"
                                class="btn btn-sm btn-danger position-absolute top-0 end-0 m-1 rounded-circle p-0"
                                style="width: 24px; height: 24px;"
                                onclick="postImageUploader.removeImage(${index})">
                            <i class="bi bi-x"></i>
                        </button>
                        <input type="hidden"
                               name="imageIds[${index}]"
                               value="${uploadResult.imageId}">
                    </div>
                `;
                    container.insertAdjacentHTML('beforeend', previewHtml);
                };
                reader.readAsDataURL(file);

                // 업로드된 이미지 정보 저장
                this.uploadedImages.push({
                    file: file,
                    imageId: uploadResult.imageId
                });
            }

            removeImage(index) {
                const item = document.querySelector(`.image-preview-item[data-index="${index}"]`);
                if (item) {
                    item.remove();
                }

                // 배열에서 제거
                this.uploadedImages.splice(index, 1);

                // 인덱스 재정렬
                this.reindexImages();
                this.updateUploadCount();
            }

            reindexImages() {
                const container = document.getElementById('modal-image-upload-container');
                const items = container.querySelectorAll('.image-preview-item');

                items.forEach((item, newIndex) => {
                    item.setAttribute('data-index', newIndex);
                    const input = item.querySelector('input[type="hidden"]');
                    if (input) {
                        input.name = `imageKeys[${newIndex}]`;
                    }
                    const button = item.querySelector('button');
                    if (button) {
                        button.setAttribute('onclick', `postImageUploader.removeImage(${newIndex})`);
                    }
                });
            }

            updateUploadCount() {
                const countElement = document.getElementById('modal-upload-count');
                if (countElement) {
                    countElement.textContent = `${this.uploadedImages.length}/${this.maxImages}`;
                }

                // 최대 개수에 도달하면 파일 선택 버튼 비활성화
                const fileInput = document.getElementById('modal-image-file-input');
                const label = fileInput?.previousElementSibling;

                if (this.uploadedImages.length >= this.maxImages) {
                    fileInput?.setAttribute('disabled', 'disabled');
                    label?.classList.add('disabled');
                } else {
                    fileInput?.removeAttribute('disabled');
                    label?.classList.remove('disabled');
                }
            }

            showProgress() {
                const progressContainer = document.getElementById('modal-upload-progress');
                if (progressContainer) {
                    progressContainer.style.display = 'block';
                    this.updateProgress(0);
                }
            }

            hideProgress() {
                const progressContainer = document.getElementById('modal-upload-progress');
                if (progressContainer) {
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                        this.updateProgress(0);
                    }, 500);
                }
            }

            updateProgress(percent) {
                const progressBar = document.getElementById('modal-upload-progress-bar');
                const progressText = document.getElementById('modal-upload-progress-text');

                if (progressBar) {
                    progressBar.style.width = `${percent}%`;
                }
                if (progressText) {
                    progressText.textContent = `${Math.round(percent)}%`;
                }
            }

            showError(message) {
                // Bootstrap 토스트나 알림을 사용하여 에러 메시지 표시
                console.error(message);
                alert(message);
            }

            resetUploader() {
                this.uploadedImages = [];
                this.uploadQueue = [];
                this.isUploading = false;

                const container = document.getElementById('modal-image-upload-container');
                if (container) {
                    container.innerHTML = '';
                }

                this.updateUploadCount();
                this.hideProgress();
            }
        }

        // 전역 인스턴스 생성
        let postImageUploader;
        document.addEventListener('DOMContentLoaded', () => {
            postImageUploader = new PostImageUploader();
        });
    </script>
</div>

</body>
</html>
